// Code generated by scripts/generate_go_funcs; DO NOT EDIT.
package jq

import (
	"sort"
	"strconv"
	"strings"

	"github.com/mjwhitta/errors"
)

// Get will return the value for the specified key(s) as a any.
func (j *JSON) Get(keys ...any) (ret any) {
	ret, _ = j.MustGet(keys...)
	return
}

// GetArray will return an array for the specified key(s) as an
// []any.
func (j *JSON) GetArray(keys ...any) (ret []any) {
	ret, _ = j.MustGetArray(keys...)
	return
}

// GetMap will return a map for the specified key(s) as a
// map[string]any.
func (j *JSON) GetMap(keys ...any) (ret map[string]any) {
	ret, _ = j.MustGetMap(keys...)
	return
}

// MustGet will return the value for the specified key(s) as a any.
func (j *JSON) MustGet(keys ...any) (any, error) {
	return j.nestedGetKey(keys)
}

func asBool(keys []any, v any) (ret bool, e error) {
	switch v := v.(type) {
	case bool:
		ret = v
	default:
		e = errors.Newf("key %v is not of type bool", keys)
	}
	return
}

// GetBool will return the value for the specified key(s) as a
// bool.
func (j *JSON) GetBool(keys ...any) (ret bool) {
	ret, _ = j.MustGetBool(keys...)
	return
}

// GetBoolArray will return an array for the specified key(s) as a
// []bool.
func (j *JSON) GetBoolArray(keys ...any) (ret []bool) {
	ret, _ = j.MustGetBoolArray(keys...)
	return
}

// GetBoolMap will return a map for the specified key(s) as a
// map[string]bool.
func (j *JSON) GetBoolMap(keys ...any) (ret map[string]bool) {
	ret, _ = j.MustGetBoolMap(keys...)
	return
}

// MustGetBool will return the value for the specified key(s) as a
// bool.
func (j *JSON) MustGetBool(keys ...any) (ret bool, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asBool(keys, val) // No need to wrap e
	return
}

// MustGetBoolArray will return an array for the specified key(s)
// as a []bool.
func (j *JSON) MustGetBoolArray(keys ...any) (ret []bool, e error) {
	var tmp bool
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]bool); ok {
		ret = val.([]bool)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []bool", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asBool(keys, v); e != nil {
			ret = []bool{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetBoolMap will return a map for the specified key(s) as a
// map[string]bool.
func (j *JSON) MustGetBoolMap(keys ...any) (ret map[string]bool, e error) {
	var val any

	ret = map[string]bool{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]bool); ok {
		ret = val.(map[string]bool)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asBool(keys, v); e != nil {
			ret = map[string]bool{}
			return
		}
	}

	return
}

func asFloat32(keys []any, v any) (ret float32, e error) {
	switch v := v.(type) {
	case float32:
		ret = float32(v)
	case float64:
		ret = float32(v)
	case int:
		ret = float32(v)
	case int8:
		ret = float32(v)
	case int16:
		ret = float32(v)
	case int32:
		ret = float32(v)
	case int64:
		ret = float32(v)
	case uint:
		ret = float32(v)
	case uint8:
		ret = float32(v)
	case uint16:
		ret = float32(v)
	case uint32:
		ret = float32(v)
	case uint64:
		ret = float32(v)
	default:
		e = errors.Newf("key %v is not of type float32", keys)
	}
	return
}

// GetFloat32 will return the value for the specified key(s) as a
// float32.
func (j *JSON) GetFloat32(keys ...any) (ret float32) {
	ret, _ = j.MustGetFloat32(keys...)
	return
}

// GetFloat32Array will return an array for the specified key(s) as a
// []float32.
func (j *JSON) GetFloat32Array(keys ...any) (ret []float32) {
	ret, _ = j.MustGetFloat32Array(keys...)
	return
}

// GetFloat32Map will return a map for the specified key(s) as a
// map[string]float32.
func (j *JSON) GetFloat32Map(keys ...any) (ret map[string]float32) {
	ret, _ = j.MustGetFloat32Map(keys...)
	return
}

// MustGetFloat32 will return the value for the specified key(s) as a
// float32.
func (j *JSON) MustGetFloat32(keys ...any) (ret float32, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asFloat32(keys, val) // No need to wrap e
	return
}

// MustGetFloat32Array will return an array for the specified key(s)
// as a []float32.
func (j *JSON) MustGetFloat32Array(keys ...any) (ret []float32, e error) {
	var tmp float32
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]float32); ok {
		ret = val.([]float32)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []float32", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asFloat32(keys, v); e != nil {
			ret = []float32{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetFloat32Map will return a map for the specified key(s) as a
// map[string]float32.
func (j *JSON) MustGetFloat32Map(keys ...any) (ret map[string]float32, e error) {
	var val any

	ret = map[string]float32{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]float32); ok {
		ret = val.(map[string]float32)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asFloat32(keys, v); e != nil {
			ret = map[string]float32{}
			return
		}
	}

	return
}

func asFloat64(keys []any, v any) (ret float64, e error) {
	switch v := v.(type) {
	case float32:
		ret = float64(v)
	case float64:
		ret = float64(v)
	case int:
		ret = float64(v)
	case int8:
		ret = float64(v)
	case int16:
		ret = float64(v)
	case int32:
		ret = float64(v)
	case int64:
		ret = float64(v)
	case uint:
		ret = float64(v)
	case uint8:
		ret = float64(v)
	case uint16:
		ret = float64(v)
	case uint32:
		ret = float64(v)
	case uint64:
		ret = float64(v)
	default:
		e = errors.Newf("key %v is not of type float64", keys)
	}
	return
}

// GetFloat64 will return the value for the specified key(s) as a
// float64.
func (j *JSON) GetFloat64(keys ...any) (ret float64) {
	ret, _ = j.MustGetFloat64(keys...)
	return
}

// GetFloat64Array will return an array for the specified key(s) as a
// []float64.
func (j *JSON) GetFloat64Array(keys ...any) (ret []float64) {
	ret, _ = j.MustGetFloat64Array(keys...)
	return
}

// GetFloat64Map will return a map for the specified key(s) as a
// map[string]float64.
func (j *JSON) GetFloat64Map(keys ...any) (ret map[string]float64) {
	ret, _ = j.MustGetFloat64Map(keys...)
	return
}

// MustGetFloat64 will return the value for the specified key(s) as a
// float64.
func (j *JSON) MustGetFloat64(keys ...any) (ret float64, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asFloat64(keys, val) // No need to wrap e
	return
}

// MustGetFloat64Array will return an array for the specified key(s)
// as a []float64.
func (j *JSON) MustGetFloat64Array(keys ...any) (ret []float64, e error) {
	var tmp float64
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]float64); ok {
		ret = val.([]float64)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []float64", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asFloat64(keys, v); e != nil {
			ret = []float64{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetFloat64Map will return a map for the specified key(s) as a
// map[string]float64.
func (j *JSON) MustGetFloat64Map(keys ...any) (ret map[string]float64, e error) {
	var val any

	ret = map[string]float64{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]float64); ok {
		ret = val.(map[string]float64)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asFloat64(keys, v); e != nil {
			ret = map[string]float64{}
			return
		}
	}

	return
}

func asInt(keys []any, v any) (ret int, e error) {
	switch v := v.(type) {
	case float32:
		ret = int(v)
	case float64:
		ret = int(v)
	case int:
		ret = int(v)
	case int8:
		ret = int(v)
	case int16:
		ret = int(v)
	case int32:
		ret = int(v)
	case int64:
		ret = int(v)
	case uint:
		ret = int(v)
	case uint8:
		ret = int(v)
	case uint16:
		ret = int(v)
	case uint32:
		ret = int(v)
	case uint64:
		ret = int(v)
	default:
		e = errors.Newf("key %v is not of type int", keys)
	}
	return
}

// GetInt will return the value for the specified key(s) as a
// int.
func (j *JSON) GetInt(keys ...any) (ret int) {
	ret, _ = j.MustGetInt(keys...)
	return
}

// GetIntArray will return an array for the specified key(s) as a
// []int.
func (j *JSON) GetIntArray(keys ...any) (ret []int) {
	ret, _ = j.MustGetIntArray(keys...)
	return
}

// GetIntMap will return a map for the specified key(s) as a
// map[string]int.
func (j *JSON) GetIntMap(keys ...any) (ret map[string]int) {
	ret, _ = j.MustGetIntMap(keys...)
	return
}

// MustGetInt will return the value for the specified key(s) as a
// int.
func (j *JSON) MustGetInt(keys ...any) (ret int, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asInt(keys, val) // No need to wrap e
	return
}

// MustGetIntArray will return an array for the specified key(s)
// as a []int.
func (j *JSON) MustGetIntArray(keys ...any) (ret []int, e error) {
	var tmp int
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]int); ok {
		ret = val.([]int)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []int", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asInt(keys, v); e != nil {
			ret = []int{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetIntMap will return a map for the specified key(s) as a
// map[string]int.
func (j *JSON) MustGetIntMap(keys ...any) (ret map[string]int, e error) {
	var val any

	ret = map[string]int{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]int); ok {
		ret = val.(map[string]int)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asInt(keys, v); e != nil {
			ret = map[string]int{}
			return
		}
	}

	return
}

func asInt8(keys []any, v any) (ret int8, e error) {
	switch v := v.(type) {
	case float32:
		ret = int8(v)
	case float64:
		ret = int8(v)
	case int:
		ret = int8(v)
	case int8:
		ret = int8(v)
	case int16:
		ret = int8(v)
	case int32:
		ret = int8(v)
	case int64:
		ret = int8(v)
	case uint:
		ret = int8(v)
	case uint8:
		ret = int8(v)
	case uint16:
		ret = int8(v)
	case uint32:
		ret = int8(v)
	case uint64:
		ret = int8(v)
	default:
		e = errors.Newf("key %v is not of type int8", keys)
	}
	return
}

// GetInt8 will return the value for the specified key(s) as a
// int8.
func (j *JSON) GetInt8(keys ...any) (ret int8) {
	ret, _ = j.MustGetInt8(keys...)
	return
}

// GetInt8Array will return an array for the specified key(s) as a
// []int8.
func (j *JSON) GetInt8Array(keys ...any) (ret []int8) {
	ret, _ = j.MustGetInt8Array(keys...)
	return
}

// GetInt8Map will return a map for the specified key(s) as a
// map[string]int8.
func (j *JSON) GetInt8Map(keys ...any) (ret map[string]int8) {
	ret, _ = j.MustGetInt8Map(keys...)
	return
}

// MustGetInt8 will return the value for the specified key(s) as a
// int8.
func (j *JSON) MustGetInt8(keys ...any) (ret int8, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asInt8(keys, val) // No need to wrap e
	return
}

// MustGetInt8Array will return an array for the specified key(s)
// as a []int8.
func (j *JSON) MustGetInt8Array(keys ...any) (ret []int8, e error) {
	var tmp int8
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]int8); ok {
		ret = val.([]int8)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []int8", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asInt8(keys, v); e != nil {
			ret = []int8{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetInt8Map will return a map for the specified key(s) as a
// map[string]int8.
func (j *JSON) MustGetInt8Map(keys ...any) (ret map[string]int8, e error) {
	var val any

	ret = map[string]int8{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]int8); ok {
		ret = val.(map[string]int8)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asInt8(keys, v); e != nil {
			ret = map[string]int8{}
			return
		}
	}

	return
}

func asInt16(keys []any, v any) (ret int16, e error) {
	switch v := v.(type) {
	case float32:
		ret = int16(v)
	case float64:
		ret = int16(v)
	case int:
		ret = int16(v)
	case int8:
		ret = int16(v)
	case int16:
		ret = int16(v)
	case int32:
		ret = int16(v)
	case int64:
		ret = int16(v)
	case uint:
		ret = int16(v)
	case uint8:
		ret = int16(v)
	case uint16:
		ret = int16(v)
	case uint32:
		ret = int16(v)
	case uint64:
		ret = int16(v)
	default:
		e = errors.Newf("key %v is not of type int16", keys)
	}
	return
}

// GetInt16 will return the value for the specified key(s) as a
// int16.
func (j *JSON) GetInt16(keys ...any) (ret int16) {
	ret, _ = j.MustGetInt16(keys...)
	return
}

// GetInt16Array will return an array for the specified key(s) as a
// []int16.
func (j *JSON) GetInt16Array(keys ...any) (ret []int16) {
	ret, _ = j.MustGetInt16Array(keys...)
	return
}

// GetInt16Map will return a map for the specified key(s) as a
// map[string]int16.
func (j *JSON) GetInt16Map(keys ...any) (ret map[string]int16) {
	ret, _ = j.MustGetInt16Map(keys...)
	return
}

// MustGetInt16 will return the value for the specified key(s) as a
// int16.
func (j *JSON) MustGetInt16(keys ...any) (ret int16, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asInt16(keys, val) // No need to wrap e
	return
}

// MustGetInt16Array will return an array for the specified key(s)
// as a []int16.
func (j *JSON) MustGetInt16Array(keys ...any) (ret []int16, e error) {
	var tmp int16
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]int16); ok {
		ret = val.([]int16)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []int16", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asInt16(keys, v); e != nil {
			ret = []int16{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetInt16Map will return a map for the specified key(s) as a
// map[string]int16.
func (j *JSON) MustGetInt16Map(keys ...any) (ret map[string]int16, e error) {
	var val any

	ret = map[string]int16{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]int16); ok {
		ret = val.(map[string]int16)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asInt16(keys, v); e != nil {
			ret = map[string]int16{}
			return
		}
	}

	return
}

func asInt32(keys []any, v any) (ret int32, e error) {
	switch v := v.(type) {
	case float32:
		ret = int32(v)
	case float64:
		ret = int32(v)
	case int:
		ret = int32(v)
	case int8:
		ret = int32(v)
	case int16:
		ret = int32(v)
	case int32:
		ret = int32(v)
	case int64:
		ret = int32(v)
	case uint:
		ret = int32(v)
	case uint8:
		ret = int32(v)
	case uint16:
		ret = int32(v)
	case uint32:
		ret = int32(v)
	case uint64:
		ret = int32(v)
	default:
		e = errors.Newf("key %v is not of type int32", keys)
	}
	return
}

// GetInt32 will return the value for the specified key(s) as a
// int32.
func (j *JSON) GetInt32(keys ...any) (ret int32) {
	ret, _ = j.MustGetInt32(keys...)
	return
}

// GetInt32Array will return an array for the specified key(s) as a
// []int32.
func (j *JSON) GetInt32Array(keys ...any) (ret []int32) {
	ret, _ = j.MustGetInt32Array(keys...)
	return
}

// GetInt32Map will return a map for the specified key(s) as a
// map[string]int32.
func (j *JSON) GetInt32Map(keys ...any) (ret map[string]int32) {
	ret, _ = j.MustGetInt32Map(keys...)
	return
}

// MustGetInt32 will return the value for the specified key(s) as a
// int32.
func (j *JSON) MustGetInt32(keys ...any) (ret int32, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asInt32(keys, val) // No need to wrap e
	return
}

// MustGetInt32Array will return an array for the specified key(s)
// as a []int32.
func (j *JSON) MustGetInt32Array(keys ...any) (ret []int32, e error) {
	var tmp int32
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]int32); ok {
		ret = val.([]int32)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []int32", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asInt32(keys, v); e != nil {
			ret = []int32{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetInt32Map will return a map for the specified key(s) as a
// map[string]int32.
func (j *JSON) MustGetInt32Map(keys ...any) (ret map[string]int32, e error) {
	var val any

	ret = map[string]int32{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]int32); ok {
		ret = val.(map[string]int32)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asInt32(keys, v); e != nil {
			ret = map[string]int32{}
			return
		}
	}

	return
}

func asInt64(keys []any, v any) (ret int64, e error) {
	switch v := v.(type) {
	case float32:
		ret = int64(v)
	case float64:
		ret = int64(v)
	case int:
		ret = int64(v)
	case int8:
		ret = int64(v)
	case int16:
		ret = int64(v)
	case int32:
		ret = int64(v)
	case int64:
		ret = int64(v)
	case uint:
		ret = int64(v)
	case uint8:
		ret = int64(v)
	case uint16:
		ret = int64(v)
	case uint32:
		ret = int64(v)
	case uint64:
		ret = int64(v)
	default:
		e = errors.Newf("key %v is not of type int64", keys)
	}
	return
}

// GetInt64 will return the value for the specified key(s) as a
// int64.
func (j *JSON) GetInt64(keys ...any) (ret int64) {
	ret, _ = j.MustGetInt64(keys...)
	return
}

// GetInt64Array will return an array for the specified key(s) as a
// []int64.
func (j *JSON) GetInt64Array(keys ...any) (ret []int64) {
	ret, _ = j.MustGetInt64Array(keys...)
	return
}

// GetInt64Map will return a map for the specified key(s) as a
// map[string]int64.
func (j *JSON) GetInt64Map(keys ...any) (ret map[string]int64) {
	ret, _ = j.MustGetInt64Map(keys...)
	return
}

// MustGetInt64 will return the value for the specified key(s) as a
// int64.
func (j *JSON) MustGetInt64(keys ...any) (ret int64, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asInt64(keys, val) // No need to wrap e
	return
}

// MustGetInt64Array will return an array for the specified key(s)
// as a []int64.
func (j *JSON) MustGetInt64Array(keys ...any) (ret []int64, e error) {
	var tmp int64
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]int64); ok {
		ret = val.([]int64)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []int64", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asInt64(keys, v); e != nil {
			ret = []int64{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetInt64Map will return a map for the specified key(s) as a
// map[string]int64.
func (j *JSON) MustGetInt64Map(keys ...any) (ret map[string]int64, e error) {
	var val any

	ret = map[string]int64{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]int64); ok {
		ret = val.(map[string]int64)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asInt64(keys, v); e != nil {
			ret = map[string]int64{}
			return
		}
	}

	return
}

func asString(keys []any, v any) (ret string, e error) {
	switch v := v.(type) {
	case string:
		ret = v
	default:
		e = errors.Newf("key %v is not of type string", keys)
	}
	return
}

// GetString will return the value for the specified key(s) as a
// string.
func (j *JSON) GetString(keys ...any) (ret string) {
	ret, _ = j.MustGetString(keys...)
	return
}

// GetStringArray will return an array for the specified key(s) as a
// []string.
func (j *JSON) GetStringArray(keys ...any) (ret []string) {
	ret, _ = j.MustGetStringArray(keys...)
	return
}

// GetStringMap will return a map for the specified key(s) as a
// map[string]string.
func (j *JSON) GetStringMap(keys ...any) (ret map[string]string) {
	ret, _ = j.MustGetStringMap(keys...)
	return
}

// MustGetString will return the value for the specified key(s) as a
// string.
func (j *JSON) MustGetString(keys ...any) (ret string, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asString(keys, val) // No need to wrap e
	return
}

// MustGetStringArray will return an array for the specified key(s)
// as a []string.
func (j *JSON) MustGetStringArray(keys ...any) (ret []string, e error) {
	var tmp string
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]string); ok {
		ret = val.([]string)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []string", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asString(keys, v); e != nil {
			ret = []string{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetStringMap will return a map for the specified key(s) as a
// map[string]string.
func (j *JSON) MustGetStringMap(keys ...any) (ret map[string]string, e error) {
	var val any

	ret = map[string]string{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]string); ok {
		ret = val.(map[string]string)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asString(keys, v); e != nil {
			ret = map[string]string{}
			return
		}
	}

	return
}

func asUint(keys []any, v any) (ret uint, e error) {
	switch v := v.(type) {
	case float32:
		ret = uint(v)
	case float64:
		ret = uint(v)
	case int:
		ret = uint(v)
	case int8:
		ret = uint(v)
	case int16:
		ret = uint(v)
	case int32:
		ret = uint(v)
	case int64:
		ret = uint(v)
	case uint:
		ret = uint(v)
	case uint8:
		ret = uint(v)
	case uint16:
		ret = uint(v)
	case uint32:
		ret = uint(v)
	case uint64:
		ret = uint(v)
	default:
		e = errors.Newf("key %v is not of type uint", keys)
	}
	return
}

// GetUint will return the value for the specified key(s) as a
// uint.
func (j *JSON) GetUint(keys ...any) (ret uint) {
	ret, _ = j.MustGetUint(keys...)
	return
}

// GetUintArray will return an array for the specified key(s) as a
// []uint.
func (j *JSON) GetUintArray(keys ...any) (ret []uint) {
	ret, _ = j.MustGetUintArray(keys...)
	return
}

// GetUintMap will return a map for the specified key(s) as a
// map[string]uint.
func (j *JSON) GetUintMap(keys ...any) (ret map[string]uint) {
	ret, _ = j.MustGetUintMap(keys...)
	return
}

// MustGetUint will return the value for the specified key(s) as a
// uint.
func (j *JSON) MustGetUint(keys ...any) (ret uint, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asUint(keys, val) // No need to wrap e
	return
}

// MustGetUintArray will return an array for the specified key(s)
// as a []uint.
func (j *JSON) MustGetUintArray(keys ...any) (ret []uint, e error) {
	var tmp uint
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]uint); ok {
		ret = val.([]uint)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []uint", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asUint(keys, v); e != nil {
			ret = []uint{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetUintMap will return a map for the specified key(s) as a
// map[string]uint.
func (j *JSON) MustGetUintMap(keys ...any) (ret map[string]uint, e error) {
	var val any

	ret = map[string]uint{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]uint); ok {
		ret = val.(map[string]uint)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asUint(keys, v); e != nil {
			ret = map[string]uint{}
			return
		}
	}

	return
}

func asUint8(keys []any, v any) (ret uint8, e error) {
	switch v := v.(type) {
	case float32:
		ret = uint8(v)
	case float64:
		ret = uint8(v)
	case int:
		ret = uint8(v)
	case int8:
		ret = uint8(v)
	case int16:
		ret = uint8(v)
	case int32:
		ret = uint8(v)
	case int64:
		ret = uint8(v)
	case uint:
		ret = uint8(v)
	case uint8:
		ret = uint8(v)
	case uint16:
		ret = uint8(v)
	case uint32:
		ret = uint8(v)
	case uint64:
		ret = uint8(v)
	default:
		e = errors.Newf("key %v is not of type uint8", keys)
	}
	return
}

// GetUint8 will return the value for the specified key(s) as a
// uint8.
func (j *JSON) GetUint8(keys ...any) (ret uint8) {
	ret, _ = j.MustGetUint8(keys...)
	return
}

// GetUint8Array will return an array for the specified key(s) as a
// []uint8.
func (j *JSON) GetUint8Array(keys ...any) (ret []uint8) {
	ret, _ = j.MustGetUint8Array(keys...)
	return
}

// GetUint8Map will return a map for the specified key(s) as a
// map[string]uint8.
func (j *JSON) GetUint8Map(keys ...any) (ret map[string]uint8) {
	ret, _ = j.MustGetUint8Map(keys...)
	return
}

// MustGetUint8 will return the value for the specified key(s) as a
// uint8.
func (j *JSON) MustGetUint8(keys ...any) (ret uint8, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asUint8(keys, val) // No need to wrap e
	return
}

// MustGetUint8Array will return an array for the specified key(s)
// as a []uint8.
func (j *JSON) MustGetUint8Array(keys ...any) (ret []uint8, e error) {
	var tmp uint8
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]uint8); ok {
		ret = val.([]uint8)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []uint8", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asUint8(keys, v); e != nil {
			ret = []uint8{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetUint8Map will return a map for the specified key(s) as a
// map[string]uint8.
func (j *JSON) MustGetUint8Map(keys ...any) (ret map[string]uint8, e error) {
	var val any

	ret = map[string]uint8{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]uint8); ok {
		ret = val.(map[string]uint8)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asUint8(keys, v); e != nil {
			ret = map[string]uint8{}
			return
		}
	}

	return
}

func asUint16(keys []any, v any) (ret uint16, e error) {
	switch v := v.(type) {
	case float32:
		ret = uint16(v)
	case float64:
		ret = uint16(v)
	case int:
		ret = uint16(v)
	case int8:
		ret = uint16(v)
	case int16:
		ret = uint16(v)
	case int32:
		ret = uint16(v)
	case int64:
		ret = uint16(v)
	case uint:
		ret = uint16(v)
	case uint8:
		ret = uint16(v)
	case uint16:
		ret = uint16(v)
	case uint32:
		ret = uint16(v)
	case uint64:
		ret = uint16(v)
	default:
		e = errors.Newf("key %v is not of type uint16", keys)
	}
	return
}

// GetUint16 will return the value for the specified key(s) as a
// uint16.
func (j *JSON) GetUint16(keys ...any) (ret uint16) {
	ret, _ = j.MustGetUint16(keys...)
	return
}

// GetUint16Array will return an array for the specified key(s) as a
// []uint16.
func (j *JSON) GetUint16Array(keys ...any) (ret []uint16) {
	ret, _ = j.MustGetUint16Array(keys...)
	return
}

// GetUint16Map will return a map for the specified key(s) as a
// map[string]uint16.
func (j *JSON) GetUint16Map(keys ...any) (ret map[string]uint16) {
	ret, _ = j.MustGetUint16Map(keys...)
	return
}

// MustGetUint16 will return the value for the specified key(s) as a
// uint16.
func (j *JSON) MustGetUint16(keys ...any) (ret uint16, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asUint16(keys, val) // No need to wrap e
	return
}

// MustGetUint16Array will return an array for the specified key(s)
// as a []uint16.
func (j *JSON) MustGetUint16Array(keys ...any) (ret []uint16, e error) {
	var tmp uint16
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]uint16); ok {
		ret = val.([]uint16)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []uint16", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asUint16(keys, v); e != nil {
			ret = []uint16{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetUint16Map will return a map for the specified key(s) as a
// map[string]uint16.
func (j *JSON) MustGetUint16Map(keys ...any) (ret map[string]uint16, e error) {
	var val any

	ret = map[string]uint16{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]uint16); ok {
		ret = val.(map[string]uint16)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asUint16(keys, v); e != nil {
			ret = map[string]uint16{}
			return
		}
	}

	return
}

func asUint32(keys []any, v any) (ret uint32, e error) {
	switch v := v.(type) {
	case float32:
		ret = uint32(v)
	case float64:
		ret = uint32(v)
	case int:
		ret = uint32(v)
	case int8:
		ret = uint32(v)
	case int16:
		ret = uint32(v)
	case int32:
		ret = uint32(v)
	case int64:
		ret = uint32(v)
	case uint:
		ret = uint32(v)
	case uint8:
		ret = uint32(v)
	case uint16:
		ret = uint32(v)
	case uint32:
		ret = uint32(v)
	case uint64:
		ret = uint32(v)
	default:
		e = errors.Newf("key %v is not of type uint32", keys)
	}
	return
}

// GetUint32 will return the value for the specified key(s) as a
// uint32.
func (j *JSON) GetUint32(keys ...any) (ret uint32) {
	ret, _ = j.MustGetUint32(keys...)
	return
}

// GetUint32Array will return an array for the specified key(s) as a
// []uint32.
func (j *JSON) GetUint32Array(keys ...any) (ret []uint32) {
	ret, _ = j.MustGetUint32Array(keys...)
	return
}

// GetUint32Map will return a map for the specified key(s) as a
// map[string]uint32.
func (j *JSON) GetUint32Map(keys ...any) (ret map[string]uint32) {
	ret, _ = j.MustGetUint32Map(keys...)
	return
}

// MustGetUint32 will return the value for the specified key(s) as a
// uint32.
func (j *JSON) MustGetUint32(keys ...any) (ret uint32, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asUint32(keys, val) // No need to wrap e
	return
}

// MustGetUint32Array will return an array for the specified key(s)
// as a []uint32.
func (j *JSON) MustGetUint32Array(keys ...any) (ret []uint32, e error) {
	var tmp uint32
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]uint32); ok {
		ret = val.([]uint32)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []uint32", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asUint32(keys, v); e != nil {
			ret = []uint32{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetUint32Map will return a map for the specified key(s) as a
// map[string]uint32.
func (j *JSON) MustGetUint32Map(keys ...any) (ret map[string]uint32, e error) {
	var val any

	ret = map[string]uint32{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]uint32); ok {
		ret = val.(map[string]uint32)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asUint32(keys, v); e != nil {
			ret = map[string]uint32{}
			return
		}
	}

	return
}

func asUint64(keys []any, v any) (ret uint64, e error) {
	switch v := v.(type) {
	case float32:
		ret = uint64(v)
	case float64:
		ret = uint64(v)
	case int:
		ret = uint64(v)
	case int8:
		ret = uint64(v)
	case int16:
		ret = uint64(v)
	case int32:
		ret = uint64(v)
	case int64:
		ret = uint64(v)
	case uint:
		ret = uint64(v)
	case uint8:
		ret = uint64(v)
	case uint16:
		ret = uint64(v)
	case uint32:
		ret = uint64(v)
	case uint64:
		ret = uint64(v)
	default:
		e = errors.Newf("key %v is not of type uint64", keys)
	}
	return
}

// GetUint64 will return the value for the specified key(s) as a
// uint64.
func (j *JSON) GetUint64(keys ...any) (ret uint64) {
	ret, _ = j.MustGetUint64(keys...)
	return
}

// GetUint64Array will return an array for the specified key(s) as a
// []uint64.
func (j *JSON) GetUint64Array(keys ...any) (ret []uint64) {
	ret, _ = j.MustGetUint64Array(keys...)
	return
}

// GetUint64Map will return a map for the specified key(s) as a
// map[string]uint64.
func (j *JSON) GetUint64Map(keys ...any) (ret map[string]uint64) {
	ret, _ = j.MustGetUint64Map(keys...)
	return
}

// MustGetUint64 will return the value for the specified key(s) as a
// uint64.
func (j *JSON) MustGetUint64(keys ...any) (ret uint64, e error) {
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	ret, e = asUint64(keys, val) // No need to wrap e
	return
}

// MustGetUint64Array will return an array for the specified key(s)
// as a []uint64.
func (j *JSON) MustGetUint64Array(keys ...any) (ret []uint64, e error) {
	var tmp uint64
	var val any

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.([]uint64); ok {
		ret = val.([]uint64)
		return
	}

	if _, ok := val.([]any); !ok {
		e = errors.Newf("key %v is not of type []uint64", keys)
		return
	}

	for _, v := range val.([]any) {
		// No need to wrap e
		if tmp, e = asUint64(keys, v); e != nil {
			ret = []uint64{}
			return
		}
		ret = append(ret, tmp)
	}

	return
}

// MustGetUint64Map will return a map for the specified key(s) as a
// map[string]uint64.
func (j *JSON) MustGetUint64Map(keys ...any) (ret map[string]uint64, e error) {
	var val any

	ret = map[string]uint64{}

	if val, e = j.nestedGetKey(keys); e != nil {
		return
	}

	if _, ok := val.(map[string]uint64); ok {
		ret = val.(map[string]uint64)
		return
	}

	for k, v := range val.(map[string]any) {
		// No need to wrap e
		if ret[k], e = asUint64(keys, v); e != nil {
			ret = map[string]uint64{}
			return
		}
	}

	return
}

func mustGetArrayKeys(val any) (ret []string) {
	switch val.(type) {
	case []bool:
		for i := 0; i < len(val.([]bool)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []string:
		for i := 0; i < len(val.([]string)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []any:
		for i := 0; i < len(val.([]any)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	}

	return
}

func mustGetFloatArrayKeys(val any) (ret []string) {
	switch val.(type) {
	case []float32:
		for i := 0; i < len(val.([]float32)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []float64:
		for i := 0; i < len(val.([]float64)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	}

	return
}

func mustGetIntArrayKeys(val any) (ret []string) {
	switch val.(type) {
	case []int:
		for i := 0; i < len(val.([]int)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []int8:
		for i := 0; i < len(val.([]int8)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []int16:
		for i := 0; i < len(val.([]int16)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []int32:
		for i := 0; i < len(val.([]int32)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []int64:
		for i := 0; i < len(val.([]int64)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	}

	return
}

func mustGetUintArrayKeys(val any) (ret []string) {
	switch val.(type) {
	case []uint:
		for i := 0; i < len(val.([]uint)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []uint8:
		for i := 0; i < len(val.([]uint8)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []uint16:
		for i := 0; i < len(val.([]uint16)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []uint32:
		for i := 0; i < len(val.([]uint32)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	case []uint64:
		for i := 0; i < len(val.([]uint64)); i++ {
			ret = append(ret, strconv.Itoa(i))
		}
	}

	return
}

func mustGetArrayAsInterface(
	val any,
) (ret []any) {
	switch val.(type) {
	case []bool:
		for _, v := range val.([]bool) {
			ret = append(ret, v)
		}
	case []string:
		for _, v := range val.([]string) {
			ret = append(ret, v)
		}
	}

	return
}

func mustGetFloatArrayAsInterface(
	val any,
) (ret []any) {
	switch val.(type) {
	case []float32:
		for _, v := range val.([]float32) {
			ret = append(ret, v)
		}
	case []float64:
		for _, v := range val.([]float64) {
			ret = append(ret, v)
		}
	}

	return
}

func mustGetIntArrayAsInterface(
	val any,
) (ret []any) {
	switch val.(type) {
	case []int:
		for _, v := range val.([]int) {
			ret = append(ret, v)
		}
	case []int8:
		for _, v := range val.([]int8) {
			ret = append(ret, v)
		}
	case []int16:
		for _, v := range val.([]int16) {
			ret = append(ret, v)
		}
	case []int32:
		for _, v := range val.([]int32) {
			ret = append(ret, v)
		}
	case []int64:
		for _, v := range val.([]int64) {
			ret = append(ret, v)
		}
	}

	return
}

func mustGetUintArrayAsInterface(
	val any,
) (ret []any) {
	switch val.(type) {
	case []uint:
		for _, v := range val.([]uint) {
			ret = append(ret, v)
		}
	case []uint8:
		for _, v := range val.([]uint8) {
			ret = append(ret, v)
		}
	case []uint16:
		for _, v := range val.([]uint16) {
			ret = append(ret, v)
		}
	case []uint32:
		for _, v := range val.([]uint32) {
			ret = append(ret, v)
		}
	case []uint64:
		for _, v := range val.([]uint64) {
			ret = append(ret, v)
		}
	}

	return
}

func mustGetMapKeys(val any) (ret []string) {
	var less = func(i, j int) bool {
		if strings.EqualFold(ret[i], ret[j]) {
			return ret[i] < ret[j]
		}

		return strings.ToLower(ret[i]) < strings.ToLower(ret[j])
	}
	switch val.(type) {
	case map[string]bool:
		for k := range val.(map[string]bool) {
			ret = append(ret, k)
		}
	case map[string]string:
		for k := range val.(map[string]string) {
			ret = append(ret, k)
		}
	case map[string]any:
		for k := range val.(map[string]any) {
			ret = append(ret, k)
		}
	}

	if !sort.SliceIsSorted(ret, less) {
		sort.SliceStable(ret, less)
	}
	return
}

func mustGetFloatMapKeys(val any) (ret []string) {
	var less = func(i, j int) bool {
		if strings.EqualFold(ret[i], ret[j]) {
			return ret[i] < ret[j]
		}

		return strings.ToLower(ret[i]) < strings.ToLower(ret[j])
	}
	switch val.(type) {
	case map[string]float32:
		for k := range val.(map[string]float32) {
			ret = append(ret, k)
		}
	case map[string]float64:
		for k := range val.(map[string]float64) {
			ret = append(ret, k)
		}
	}

	if !sort.SliceIsSorted(ret, less) {
		sort.SliceStable(ret, less)
	}
	return
}

func mustGetIntMapKeys(val any) (ret []string) {
	var less = func(i, j int) bool {
		if strings.EqualFold(ret[i], ret[j]) {
			return ret[i] < ret[j]
		}

		return strings.ToLower(ret[i]) < strings.ToLower(ret[j])
	}
	switch val.(type) {
	case map[string]int:
		for k := range val.(map[string]int) {
			ret = append(ret, k)
		}
	case map[string]int8:
		for k := range val.(map[string]int8) {
			ret = append(ret, k)
		}
	case map[string]int16:
		for k := range val.(map[string]int16) {
			ret = append(ret, k)
		}
	case map[string]int32:
		for k := range val.(map[string]int32) {
			ret = append(ret, k)
		}
	case map[string]int64:
		for k := range val.(map[string]int64) {
			ret = append(ret, k)
		}
	}

	if !sort.SliceIsSorted(ret, less) {
		sort.SliceStable(ret, less)
	}
	return
}

func mustGetUintMapKeys(val any) (ret []string) {
	var less = func(i, j int) bool {
		if strings.EqualFold(ret[i], ret[j]) {
			return ret[i] < ret[j]
		}

		return strings.ToLower(ret[i]) < strings.ToLower(ret[j])
	}
	switch val.(type) {
	case map[string]uint:
		for k := range val.(map[string]uint) {
			ret = append(ret, k)
		}
	case map[string]uint8:
		for k := range val.(map[string]uint8) {
			ret = append(ret, k)
		}
	case map[string]uint16:
		for k := range val.(map[string]uint16) {
			ret = append(ret, k)
		}
	case map[string]uint32:
		for k := range val.(map[string]uint32) {
			ret = append(ret, k)
		}
	case map[string]uint64:
		for k := range val.(map[string]uint64) {
			ret = append(ret, k)
		}
	}

	if !sort.SliceIsSorted(ret, less) {
		sort.SliceStable(ret, less)
	}
	return
}

func mustGetMapAsInterface(
	val any,
) (ret map[string]any) {
	ret = map[string]any{}
	switch val.(type) {
	case map[string]bool:
		for k, v := range val.(map[string]bool) {
			ret[k] = v
		}
	case map[string]string:
		for k, v := range val.(map[string]string) {
			ret[k] = v
		}
	}

	return
}

func mustGetFloatMapAsInterface(
	val any,
) (ret map[string]any) {
	ret = map[string]any{}
	switch val.(type) {
	case map[string]float32:
		for k, v := range val.(map[string]float32) {
			ret[k] = v
		}
	case map[string]float64:
		for k, v := range val.(map[string]float64) {
			ret[k] = v
		}
	}

	return
}

func mustGetIntMapAsInterface(
	val any,
) (ret map[string]any) {
	ret = map[string]any{}
	switch val.(type) {
	case map[string]int:
		for k, v := range val.(map[string]int) {
			ret[k] = v
		}
	case map[string]int8:
		for k, v := range val.(map[string]int8) {
			ret[k] = v
		}
	case map[string]int16:
		for k, v := range val.(map[string]int16) {
			ret[k] = v
		}
	case map[string]int32:
		for k, v := range val.(map[string]int32) {
			ret[k] = v
		}
	case map[string]int64:
		for k, v := range val.(map[string]int64) {
			ret[k] = v
		}
	}

	return
}

func mustGetUintMapAsInterface(
	val any,
) (ret map[string]any) {
	ret = map[string]any{}
	switch val.(type) {
	case map[string]uint:
		for k, v := range val.(map[string]uint) {
			ret[k] = v
		}
	case map[string]uint8:
		for k, v := range val.(map[string]uint8) {
			ret[k] = v
		}
	case map[string]uint16:
		for k, v := range val.(map[string]uint16) {
			ret[k] = v
		}
	case map[string]uint32:
		for k, v := range val.(map[string]uint32) {
			ret[k] = v
		}
	case map[string]uint64:
		for k, v := range val.(map[string]uint64) {
			ret[k] = v
		}
	}

	return
}
